<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>F√≥rmula 1 - Simulador 3D (Controles Mejorados)</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="start-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #111; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 101; color: white; font-size: 24px; cursor: pointer;">
        <h1>F√≥rmula 1</h1>
        <p style="font-size: 18px;">Haz clic para iniciar</p>
    </div>

    <div id="loading-overlay" style="display: none;">
        <div class="spinner"></div>
        <p>Generando Bosque Mixto...</p>
    </div>

    <div class="touch-controls" style="display: none;">
        <div class="d-pad">
            <div id="touch-up" class="ui-button touch-button">‚ñ≤</div>
            <div id="touch-left" class="ui-button touch-button">‚óÄ</div>
            <div id="touch-right" class="ui-button touch-button">‚ñ∂</div>
            <div id="touch-down" class="ui-button touch-button">‚ñº</div>
        </div>
    </div>
    <div id="camera-button" class="ui-button">üì∑</div>

    <div id="countdown-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; justify-content: center; align-items: center; z-index: 99; font-size: 15vw; color: white; font-weight: bold; text-shadow: 0 0 20px black;"></div>

    <div id="results-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 102; background-color: rgba(0,0,0,0.8); color: white;">
        <h1 style="font-size: 5vw;">Resultados</h1>
        <div id="results-table" style="font-size: 2vw; margin-bottom: 30px;"></div>
        <button id="new-race-button" class="ui-button" style="padding: 15px 30px; font-size: 2vw;">Iniciar Otra Carrera</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // --- CONFIGURACI√ìN B√ÅSICA DE LA ESCENA ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 500, 1500);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- ILUMINACI√ìN ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.9));
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.8);
        directionalLight.position.set(-200, 250, 500);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -1000;
        directionalLight.shadow.camera.right = 1000;
        directionalLight.shadow.camera.top = 1000;
        directionalLight.shadow.camera.bottom = -1000;
        scene.add(directionalLight);

        // --- CONSTANTES Y VARIABLES DEL JUEGO ---
        const ASPHALT_WIDTH = 19.6; // 14 * 1.4
        const CURB_WIDTH = 1;
        const FENCE_BUFFER = 1;
        const GRASS_SIZE = 2500;
        const trackPoints = [
            new THREE.Vector3(0, 0, -500), new THREE.Vector3(0, 0, 0), // Recta de inicio
            new THREE.Vector3(200, 0, 200), new THREE.Vector3(400, 0, 0), // Curva 1
            new THREE.Vector3(600, 0, -200), // Extensi√≥n 1
            new THREE.Vector3(800, 0, 0), // Nueva curva amplia
            new THREE.Vector3(800, 0, -500), // Recta larga
            new THREE.Vector3(600, 0, -700), // Extensi√≥n 2
            new THREE.Vector3(400, 0, -500), new THREE.Vector3(200, 0, -700), // Curva 2
            new THREE.Vector3(-200, 0, -700),
        ];
        const trackCurve = new THREE.CatmullRomCurve3(trackPoints, true, 'catmullrom', 0.5);
        const trackLength = trackCurve.getLength();

        // --- GENERADORES DE TEXTURAS Y MATERIALES (Sin cambios) ---
        function createAsphaltMaterial() { const size = 512; const colorCanvas = document.createElement('canvas'); colorCanvas.width = size; colorCanvas.height = size; const ctx = colorCanvas.getContext('2d'); ctx.fillStyle = '#303030'; ctx.fillRect(0, 0, size, size); for (let i = 0; i < 20000; i++) { const x = Math.random() * size; const y = Math.random() * size; const c = 40 + Math.random() * 30; ctx.fillStyle = `rgb(${c},${c},${c})`; ctx.beginPath(); ctx.arc(x, y, Math.random() * 1.5, 0, Math.PI * 2); ctx.fill(); } const colorMap = new THREE.CanvasTexture(colorCanvas); colorMap.wrapS = THREE.RepeatWrapping; colorMap.wrapT = THREE.RepeatWrapping; return new THREE.MeshStandardMaterial({ map: colorMap, roughness: 0.9, metalness: 0.1 }); }
        function createCurbTexture() { const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = 32; canvas.height = 32; ctx.fillStyle = '#FFFFFF'; ctx.fillRect(0, 0, 32, 16); ctx.fillStyle = '#FF0000'; ctx.fillRect(0, 16, 32, 16); const texture = new THREE.CanvasTexture(canvas); texture.magFilter = THREE.NearestFilter; texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; return texture; }
        function createGrassMaterial() { const size = 512; const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size; const ctx = canvas.getContext('2d'); ctx.fillStyle = '#3a5921'; ctx.fillRect(0, 0, size, size); for (let i = 0; i < 15000; i++) { const x = Math.random() * size; const y = Math.random() * size; const lightness = Math.random() * 0.15; ctx.fillStyle = `rgba(255, 255, 150, ${lightness})`; ctx.fillRect(x, y, 2, 2); } const texture = new THREE.CanvasTexture(canvas); texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; texture.repeat.set(GRASS_SIZE / 50, GRASS_SIZE / 50); return new THREE.MeshStandardMaterial({ map: texture, roughness: 1, color: 0x4a7931 }); }
        function createCrowdTexture() { const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 128; const ctx = canvas.getContext('2d'); ctx.fillStyle = '#444'; ctx.fillRect(0,0,512,128); for(let i=0; i < 2000; i++) { const x = Math.random() * 512; const y = 32 + Math.random() * 96; const size = Math.random() * 2 + 1; ctx.fillStyle = `hsl(${Math.random() * 360}, 50%, ${60 + Math.random() * 20}%)`; ctx.beginPath(); ctx.arc(x, y, size, 0, Math.PI * 2); ctx.fill(); } return new THREE.CanvasTexture(canvas); }
        function createFenceTexture() { const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128; const ctx = canvas.getContext('2d'); ctx.strokeStyle = 'rgba(100, 100, 100, 0.7)'; ctx.lineWidth = 2; for(let i = -128; i < 256; i+=10) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i + 128, 128); ctx.stroke(); ctx.beginPath(); ctx.moveTo(i, 128); ctx.lineTo(i + 128, 0); ctx.stroke(); } const texture = new THREE.CanvasTexture(canvas); texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; return texture; }
        function createFlatTrackSegment(curve, width, material, yOffset = 0) { const segments = Math.floor(curve.getLength() / 2); const geometry = new THREE.BufferGeometry(); const positions = [], normals = [], uvs = [], indices = []; const repeatFactor = trackLength / 10; for (let i = 0; i <= segments; i++) { const p = i / segments; const point = curve.getPointAt(p); const tangent = curve.getTangentAt(p); const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize(); positions.push(point.x - normal.x * width / 2, yOffset, point.z - normal.z * width / 2); normals.push(0, 1, 0); uvs.push(0, p * repeatFactor); positions.push(point.x + normal.x * width / 2, yOffset, point.z + normal.z * width / 2); normals.push(0, 1, 0); uvs.push(width / 10, p * repeatFactor); } for (let i = 0; i < segments; i++) { const a = i * 2, b = a + 1, c = a + 2, d = a + 3; indices.push(a, b, c, b, d, c); } geometry.setIndex(indices); geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3)); geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3)); geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2)); const mesh = new THREE.Mesh(geometry, material); mesh.receiveShadow = true; return mesh; }
        function createOffsetFlatTrackSegment(curve, width, material, offset, yOffset) { const segments = Math.floor(curve.getLength() / 2); const geometry = new THREE.BufferGeometry(); const positions = [], normals = [], uvs = [], indices = []; for (let i = 0; i <= segments; i++) { const p = i / segments; const point = curve.getPointAt(p); const tangent = curve.getTangentAt(p); const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize(); const basePoint = point.clone().add(normal.clone().multiplyScalar(offset)); const textureRepeatFactor = 1 / (1.5 * 2); positions.push(basePoint.x - normal.x * width / 2, yOffset, basePoint.z - normal.z * width / 2); normals.push(0, 1, 0); uvs.push(0, p * trackLength * textureRepeatFactor); positions.push(basePoint.x + normal.x * width / 2, yOffset, basePoint.z + normal.z * width / 2); normals.push(0, 1, 0); uvs.push(1, p * trackLength * textureRepeatFactor); } for (let i = 0; i < segments; i++) { const a = i * 2, b = a + 1, c = a + 2, d = a + 3; indices.push(a, b, c, b, d, c); } geometry.setIndex(indices); geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3)); geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3)); geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2)); return new THREE.Mesh(geometry, material); }

        // --- L√ìGICA DE √ÅRBOLES OPTIMIZADA CON BOSQUE MIXTO ---
        const MAX_TREES_PER_TYPE = 100;
        const treeGeo = new THREE.PlaneGeometry(1, 1);
        treeGeo.translate(0, 0.5, 0);

        const treeTypes = ['frondoso', 'conifera', 'alamo'];
        const treeMeshes = {};
        const treeMaterials = {};

        const loadingManager = new THREE.LoadingManager();
        const textureLoader = new THREE.TextureLoader(loadingManager);

        treeTypes.forEach(type => {
            treeMaterials[type] = new THREE.MeshStandardMaterial({ transparent: true, alphaTest: 0.5, side: THREE.DoubleSide });
            const instancedMesh1 = new THREE.InstancedMesh(treeGeo, treeMaterials[type], MAX_TREES_PER_TYPE);
            const instancedMesh2 = new THREE.InstancedMesh(treeGeo, treeMaterials[type], MAX_TREES_PER_TYPE);
            instancedMesh1.castShadow = false; instancedMesh2.castShadow = false;
            instancedMesh1.receiveShadow = true; instancedMesh2.receiveShadow = true;
            treeMeshes[type] = [instancedMesh1, instancedMesh2];
            scene.add(instancedMesh1, instancedMesh2);
        });

        function populateMixedForest() {
            const curvePoints = trackCurve.getSpacedPoints(200);
            const fenceOffset = ASPHALT_WIDTH / 2 + CURB_WIDTH + FENCE_BUFFER;
            const minSafeDistance = fenceOffset + 1;
            const dummy = new THREE.Object3D();

            const counts = { frondoso: 0, conifera: 0, alamo: 0 };

            for (let i = 0; i < (MAX_TREES_PER_TYPE * treeTypes.length) * 5; i++) {
                const x = (Math.random() - 0.5) * (GRASS_SIZE * 0.9);
                const z = (Math.random() - 0.5) * (GRASS_SIZE * 0.9);

                let minDistanceToTrack = Infinity;
                for (const point of curvePoints) {
                    minDistanceToTrack = Math.min(minDistanceToTrack, Math.hypot(x - point.x, z - point.z));
                }

                if (minDistanceToTrack > minSafeDistance) {
                    const randomTreeType = treeTypes[Math.floor(Math.random() * treeTypes.length)];
                    if (counts[randomTreeType] < MAX_TREES_PER_TYPE) {
                        const treeHeight = 10 + Math.random() * 15;
                        const treeWidth = treeHeight / 1.8;
                        dummy.position.set(x, 0, z);
                        dummy.scale.set(treeWidth, treeHeight, 1);
                        dummy.rotation.y = 0;
                        dummy.updateMatrix();
                        treeMeshes[randomTreeType][0].setMatrixAt(counts[randomTreeType], dummy.matrix);
                        dummy.rotation.y = Math.PI / 2;
                        dummy.updateMatrix();
                        treeMeshes[randomTreeType][1].setMatrixAt(counts[randomTreeType], dummy.matrix);
                        counts[randomTreeType]++;
                    }
                }
                if (treeTypes.every(type => counts[type] >= MAX_TREES_PER_TYPE)) break;
            }

            treeTypes.forEach(type => {
                treeMeshes[type][0].count = counts[type];
                treeMeshes[type][1].count = counts[type];
                treeMeshes[type][0].instanceMatrix.needsUpdate = true;
                treeMeshes[type][1].instanceMatrix.needsUpdate = true;
            });
        }

        // --- CREACI√ìN DEL ESCENARIO ---
        function createScenery() {
            const crowdMaterial = new THREE.MeshBasicMaterial({ map: createCrowdTexture() });
            const fenceMaterial = new THREE.MeshBasicMaterial({ map: createFenceTexture(), transparent: true, alphaTest: 0.1 });
            fenceMaterial.map.repeat.set(80, 1);
            const sceneryPlanes = [ { progress: 0.95, side: 'outer', size: new THREE.Vector2(150, 30), material: crowdMaterial }, { progress: 0.2, side: 'outer', size: new THREE.Vector2(100, 25), material: crowdMaterial }, { progress: 0.6, side: 'outer', size: new THREE.Vector2(120, 28), material: crowdMaterial }, ];

            sceneryPlanes.forEach(p => {
                const point = trackCurve.getPointAt(p.progress);
                const tangent = curve.getTangentAt(p.progress);
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x);
                const sideMultiplier = p.side === 'outer' ? 1 : -1;
                const offset = ASPHALT_WIDTH / 2 + 8;
                const planeGeo = new THREE.PlaneGeometry(p.size.x, p.size.y);
                const plane = new THREE.Mesh(planeGeo, p.material);
                plane.position.copy(point).add(normal.clone().multiplyScalar(offset * sideMultiplier));
                plane.position.y = p.size.y / 2;
                plane.lookAt(point);
                scene.add(plane);
            });

            const fenceHeight = 3;
            const fenceOffset = ASPHALT_WIDTH / 2 + CURB_WIDTH + FENCE_BUFFER;
            const fenceSegments = 400; // Aumentado para la pista m√°s larga
            const fenceGeo = new THREE.PlaneGeometry(trackLength / fenceSegments, fenceHeight);
            for (let i = 0; i < fenceSegments; i++) {
                const progress = i / fenceSegments;
                const point = trackCurve.getPointAt(progress);
                const tangent = trackCurve.getTangentAt(progress);
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x);
                const fence_outer = new THREE.Mesh(fenceGeo, fenceMaterial);
                fence_outer.position.copy(point).add(normal.clone().multiplyScalar(fenceOffset));
                fence_outer.position.y = fenceHeight / 2;
                fence_outer.lookAt(point);
                scene.add(fence_outer);
                const fence_inner = new THREE.Mesh(fenceGeo, fenceMaterial);
                fence_inner.position.copy(point).add(normal.clone().multiplyScalar(-fenceOffset));
                fence_inner.position.y = fenceHeight / 2;
                fence_inner.lookAt(point.clone().add(normal.clone().multiplyScalar(-100)));
                scene.add(fence_inner);
            }
        }

        // --- L√çNEA DE META ---
        function createFinishLine() {
            const finishLineTexture = new THREE.CanvasTexture(createCheckerboardCanvas(10, 10));
            finishLineTexture.wrapS = THREE.RepeatWrapping;
            finishLineTexture.wrapT = THREE.RepeatWrapping;
            finishLineTexture.repeat.set(10, 1);
            const finishLineMaterial = new THREE.MeshBasicMaterial({ map: finishLineTexture, side: THREE.DoubleSide });
            const finishLineGeo = new THREE.PlaneGeometry(ASPHALT_WIDTH, 5);
            const finishLine = new THREE.Mesh(finishLineGeo, finishLineMaterial);

            const finishPoint = trackCurve.getPointAt(0.0001); // Ligeramente despu√©s del inicio
            const tangent = trackCurve.getTangentAt(0.0001);
            finishLine.position.copy(finishPoint);
            finishLine.position.y += 0.02; // Reducido para que est√© m√°s pegado
            finishLine.lookAt(finishPoint.clone().add(tangent));
            finishLine.rotation.x = -Math.PI / 2;
            scene.add(finishLine);
        }

        function createCheckerboardCanvas(width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const context = canvas.getContext('2d');
            context.fillStyle = 'white';
            context.fillRect(0, 0, width, height);
            context.fillStyle = 'black';
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    if ((i + j) % 2 == 0) {
                        context.fillRect(j, i, 1, 1);
                    }
                }
            }
            return canvas;
        }

        // --- INICIALIZACI√ìN DE LA ESCENA ---
        scene.add(createFlatTrackSegment(trackCurve, ASPHALT_WIDTH, createAsphaltMaterial(), 0.01));
        const curbMaterial = new THREE.MeshStandardMaterial({ map: createCurbTexture(), roughness: 0.7 });
        const curbOffset = ASPHALT_WIDTH / 2 + CURB_WIDTH / 2;
        scene.add(createOffsetFlatTrackSegment(trackCurve, CURB_WIDTH, curbMaterial, -curbOffset, 0.02));
        scene.add(createOffsetFlatTrackSegment(trackCurve, CURB_WIDTH, curbMaterial, curbOffset, 0.02));
        const groundPlane = new THREE.Mesh(new THREE.PlaneGeometry(GRASS_SIZE, GRASS_SIZE), createGrassMaterial());
        groundPlane.rotation.x = -Math.PI / 2;
        groundPlane.receiveShadow = true;
        scene.add(groundPlane);
        createScenery();

        // --- L√ìGICA DEL COCHE Y CONTROLES ---
        const car = new THREE.Group();
        const carBody = new THREE.Mesh( new THREE.BoxGeometry(2, 0.8, 4.5), new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.3, metalness: 0.2 }) );
        carBody.castShadow = true; car.add(carBody);
        const carCabin = new THREE.Mesh( new THREE.BoxGeometry(1.4, 0.7, 2), new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.1, transparent: true, opacity: 0.8 }) );
        carCabin.position.set(0, 0.75, -0.2); car.add(carCabin);
        scene.add(car);

        let carSpeed = 0, trackProgress = 0.001, lateralOffset = 0;
        const ACCELERATION = 80.0, MAX_SPEED = 200.0, FRICTION = 0.985;
        const LATERAL_SPEED = 1.5, LATERAL_FRICTION = 0.9, MAX_LATERAL_OFFSET = ASPHALT_WIDTH / 2 - 1.2;
        let gameState = 'COUNTDOWN'; // COUNTDOWN, RACE, SPECTATOR, FINISHED
        const aiCars = [];
        const raceData = {
            laps: 1,
            player: { lap: 0, finished: false, finishTime: 0 },
            ai: []
        };

        const keys = {};
        document.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
        document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

        const touchMappings = { 'touch-up': 'w', 'touch-down': 's', 'touch-left': 'a', 'touch-right': 'd' };
        Object.keys(touchMappings).forEach(id => {
            const element = document.getElementById(id);
            const key = touchMappings[id];

            const press = (e) => { e.preventDefault(); keys[key] = true; element.classList.add('active'); };
            const release = (e) => { e.preventDefault(); keys[key] = false; element.classList.remove('active'); };

            element.addEventListener('touchstart', press, { passive: false });
            element.addEventListener('touchend', release);
            element.addEventListener('touchcancel', release);
            element.addEventListener('touchleave', release);
        });

        let cameraMode = 0;
        const cameraButton = document.getElementById('camera-button');
        cameraButton.addEventListener('click', () => { cameraMode = (cameraMode + 1) % 3; });
        const cameraSettings = [
            { offset: new THREE.Vector3(0, 8, 15), lookAt: new THREE.Vector3(0, 2, 0) },
            { offset: new THREE.Vector3(0, 4, 8), lookAt: new THREE.Vector3(0, 1.5, 0) },
            { offset: new THREE.Vector3(0, 1.4, 0.2), lookAt: new THREE.Vector3(0, 1.2, -10) }
        ];
        const clock = new THREE.Clock();

        // --- L√ìGICA DE IA Y COCHES ADICIONALES ---
        function createAICars() {
            const carColors = [0x0000ff, 0x00ff00, 0xffff00, 0xffa500, 0x800080, 0x00ffff, 0xffffff];
            for (let i = 0; i < 7; i++) {
                const aiCarBody = new THREE.Mesh(new THREE.BoxGeometry(2, 0.8, 4.5), new THREE.MeshStandardMaterial({ color: carColors[i], roughness: 0.4 }));
                const aiCar = new THREE.Group();
                aiCar.add(aiCarBody);
                aiCar.userData = {
                    trackProgress: -0.005 * (i + 1),
                    lateralOffset: (Math.random() - 0.5) * MAX_LATERAL_OFFSET * 0.8,
                    speed: MAX_SPEED * (0.85 + Math.random() * 0.1)
                };
                aiCars.push(aiCar);
                scene.add(aiCar);
                raceData.ai.push({ lap: 0, finished: false, finishTime: 0 });
            }
        }

        function updateAICars(delta) {
            aiCars.forEach((aiCar, i) => {
                if (raceData.ai[i].finished) return;

                const oldProgress = aiCar.userData.trackProgress;
                aiCar.userData.trackProgress = (oldProgress + (aiCar.userData.speed / trackLength) * delta + 1) % 1;
                checkLapCompletion(aiCar, raceData.ai[i], oldProgress);

                if (Math.random() < 0.01) {
                    aiCar.userData.lateralOffset += (Math.random() - 0.5) * 0.5;
                }

                aiCars.forEach(otherCar => {
                    if (aiCar === otherCar) return;

                    const progressDiff = Math.abs(aiCar.userData.trackProgress - otherCar.userData.trackProgress);
                    const lateralDiff = Math.abs(aiCar.userData.lateralOffset - otherCar.userData.lateralOffset);

                    if (progressDiff < 0.01 && lateralDiff < 2.5) {
                        const avoidanceForce = 0.05;
                        if (aiCar.userData.lateralOffset > otherCar.userData.lateralOffset) {
                            aiCar.userData.lateralOffset += avoidanceForce;
                        } else {
                            aiCar.userData.lateralOffset -= avoidanceForce;
                        }
                    }
                });

                aiCar.userData.lateralOffset = Math.max(-MAX_LATERAL_OFFSET, Math.min(MAX_LATERAL_OFFSET, aiCar.userData.lateralOffset));

                const pos = trackCurve.getPointAt(aiCar.userData.trackProgress);
                const tangent = trackCurve.getTangentAt(aiCar.userData.trackProgress);
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x);
                aiCar.position.copy(pos).add(normal.multiplyScalar(aiCar.userData.lateralOffset));
                aiCar.position.y = 0.4;
                aiCar.lookAt(pos.clone().add(tangent));
            });
        }

        function checkLapCompletion(carObject, carRaceData, oldProgress) {
            const newProgress = carObject.userData ? carObject.userData.trackProgress : carObject.trackProgress;
            if (oldProgress > 0.9 && newProgress < 0.1) {
                carRaceData.lap++;
                if (carRaceData.lap >= raceData.laps) {
                    carRaceData.finished = true;
                    carRaceData.finishTime = clock.getElapsedTime();
                    if (carObject === car) { // Es el jugador
                        gameState = 'SPECTATOR';
                    }
                }
            }
        }


        // --- L√ìGICA DE RESULTADOS Y REINICIO ---
        function showResults() {
            gameState = 'FINISHED';
            const resultsTable = document.getElementById('results-table');
            resultsTable.innerHTML = '';

            const allRacers = [
                { name: 'Jugador', ...raceData.player },
                ...raceData.ai.map((ai, i) => ({ name: `IA ${i + 1}`, ...ai }))
            ];

            allRacers.sort((a, b) => {
                if (a.finished && !b.finished) return -1;
                if (!a.finished && b.finished) return 1;
                if (a.finished && b.finished) return a.finishTime - b.finishTime;
                return 0;
            });

            allRacers.forEach((racer, index) => {
                const time = racer.finished ? racer.finishTime.toFixed(2) + 's' : 'DNF';
                resultsTable.innerHTML += `<p>${index + 1}. ${racer.name} - ${time}</p>`;
            });

            document.getElementById('results-overlay').style.display = 'flex';
        }

        function resetRace() {
            document.getElementById('results-overlay').style.display = 'none';

            raceData.player = { lap: 0, finished: false, finishTime: 0 };
            raceData.ai = [];
            aiCars.forEach(car => scene.remove(car));
            aiCars.length = 0;

            trackProgress = 0.001;
            lateralOffset = 0;
            carSpeed = 0;

            createAICars();
            startCountdown();
        }

        document.getElementById('new-race-button').addEventListener('click', resetRace);


        // --- BUCLE DE ANIMACI√ìN ---
        function startCountdown() {
            const countdownOverlay = document.getElementById('countdown-overlay');
            const countdownSteps = [ "3", "2", "1", "GO!" ];
            let currentStep = 0;

            countdownOverlay.style.display = 'flex';

            const interval = setInterval(() => {
                if (currentStep < countdownSteps.length) {
                    countdownOverlay.textContent = countdownSteps[currentStep];
                    currentStep++;
                } else {
                    clearInterval(interval);
                    countdownOverlay.style.display = 'none';
                    gameState = 'RACE';
                }
            }, 1000);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (gameState === 'RACE' || gameState === 'SPECTATOR') {
                if (gameState === 'SPECTATOR') {
                    const allFinished = raceData.ai.every(car => car.finished);
                    if (allFinished) {
                        showResults();
                        gameState = 'FINISHED';
                    }
                }

                const oldProgress = trackProgress;
                if (gameState === 'RACE') {
                    let accelerationInput = (keys['arrowup'] || keys['w']) ? 1 : (keys['arrowdown'] || keys['s']) ? -0.5 : 0;
                    let turnInput = (keys['arrowleft'] || keys['a']) ? 1 : (keys['arrowright'] || keys['d']) ? -1 : 0;

                    carSpeed += accelerationInput * ACCELERATION * delta;
                    carSpeed *= FRICTION;
                    carSpeed = Math.max(-MAX_SPEED / 3, Math.min(MAX_SPEED, carSpeed));
                    trackProgress = (trackProgress + (carSpeed / trackLength) * delta + 1) % 1;
                    lateralOffset += turnInput * LATERAL_SPEED * delta * (Math.abs(carSpeed) / MAX_SPEED + 0.2);
                    lateralOffset *= LATERAL_FRICTION;
                    lateralOffset = Math.max(-MAX_LATERAL_OFFSET, Math.min(MAX_LATERAL_OFFSET, lateralOffset));
                }
                checkLapCompletion(car, raceData.player, oldProgress);
                updateAICars(delta);
            }

            const carPosition = trackCurve.getPointAt(trackProgress);
            const carTangent = trackCurve.getTangentAt(trackProgress);
            const carNormal = new THREE.Vector3(-tangent.z, 0, tangent.x);
            car.position.copy(carPosition).add(carNormal.multiplyScalar(lateralOffset));
            car.position.y = 0.4;
            car.lookAt(carPosition.clone().add(carTangent));

            carCabin.visible = (cameraMode !== 2);
            const currentSettings = cameraSettings[cameraMode];
            const targetCameraPosition = car.position.clone().add(currentSettings.offset.clone().applyQuaternion(car.quaternion));
            camera.position.lerp(targetCameraPosition, delta * 5.0);
            const targetLookAtPosition = car.position.clone().add(currentSettings.lookAt.clone().applyQuaternion(car.quaternion));
            camera.lookAt(targetLookAtPosition);

            renderer.render(scene, camera);
        }

        // --- INICIO ---
        const startOverlay = document.getElementById('start-overlay');
        const loadingOverlay = document.getElementById('loading-overlay');
        const touchControls = document.querySelector('.touch-controls');

        startOverlay.addEventListener('click', () => {
            startOverlay.style.display = 'none';
            loadingOverlay.style.display = 'flex';

            animate(); // Iniciar el bucle de renderizado inmediatamente

            loadingManager.onLoad = () => {
                populateMixedForest();
                createAICars();
                createFinishLine();
                loadingOverlay.style.display = 'none';
                touchControls.style.display = 'flex';
                startCountdown();
            };

            // Iniciar la carga de texturas
            treeTypes.forEach(type => {
                const url = `https://raw.githubusercontent.com/Yanzsmartwood2025/JUSN38/main/assets/images/formula-1/arbol_${type}.png`;
                textureLoader.load(url, (texture) => {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                    treeMaterials[type].map = texture;
                    treeMaterials[type].needsUpdate = true;
                });
            });
        }, { once: true });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
