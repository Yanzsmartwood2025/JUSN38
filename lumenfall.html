<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Lumenfall Demo V23</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Inter&display=swap" rel="stylesheet">
    <style>
        /* Estilos generales del cuerpo */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
        }

        /* Canvas de fondo para Three.js */
        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            display: none;
        }

        /* Contenedor de la interfaz de usuario */
        #ui-container {
            position: relative;
            z-index: 2;
            width: 100%;
            height: 100vh;
            pointer-events: none;
            display: none;
            flex-direction: column;
            justify-content: space-between;
        }

        #ui-container > * {
            pointer-events: auto;
        }

        /* Estilos para la parte superior de la UI y los controles */
        #ui-top, #controls {
            position: relative;
            width: 100%;
            box-sizing: border-box;
            color: white;
            font-family: 'Segoe UI', sans-serif;
        }

        #ui-top {
            padding: 10px;
            display: flex;
            gap: 20px;
            align-items: flex-start;
            justify-content: space-between;
        }

        /* --- CSS para las barras y la imagen de perfil --- */
        .player-info {
            display: grid;
            grid-template-areas:
                "profile stats"
                "profile name";
            grid-template-columns: auto 1fr;
            align-items: center;
            gap: 5px 15px;
        }
        
        #player-profile-container {
            grid-area: profile;
            position: relative;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            box-shadow: 0 0 10px #00aaff, 0 0 20px #00aaff, 0 0 30px #0055aa;
        }

        #player-profile-image {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: none;
            box-shadow: none;
            position: relative;
            object-fit: contain;
            object-position: 50% 50%;
        }
        
        #joziel-halo {
            position: absolute;
            top: -5px;
            left: -5px;
            width: 90px;
            height: 90px;
            border-radius: 50%;
            box-shadow: 0 0 15px #e0f7ff, inset 0 0 10px #ffffff;
            transition: box-shadow 0.3s ease-out;
            pointer-events: auto;
            cursor: pointer;
        }
        
        .stats-group {
            grid-area: stats;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-self: end;
        }
        
        .stat-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
            position: relative;
        }

        .stat-label {
            grid-area: name;
            font-family: 'Cinzel', serif;
            font-weight: 700;
            text-shadow: 1px 1px 2px black;
            font-size: 1.2em;
            text-align: left;
            align-self: start;
        }

        #energy-bar, #power-bar {
            width: 200px;
            height: 8px;
            background-color: rgba(0,0,0,0.5);
            border: 1px solid #555;
            border-radius: 10px;
            padding: 2px;
            box-shadow: 0 0 8px rgba(0,0,0,0.5);
            position: relative;
            overflow: hidden;
        }
        
        #energy-fill, #power-fill {
            height: 100%;
            border-radius: 6px;
        }

        #energy-fill {
            background-color: #00ff00;
            width: 100%;
        }
        
        #power-fill {
            background: linear-gradient(90deg, transparent 0%, rgba(52, 152, 219, 0.5) 10%, #00aaff 50%, rgba(52, 152, 219, 0.5) 90%, transparent 100%);
            transition: width 0.3s ease-out, box-shadow 0.3s ease-out;
            box-shadow: 0 0 8px #00aaff;
            animation: move-power 2s infinite linear;
        }

        @keyframes move-power {
            0% { background-position: 0% 0; }
            100% { background-position: 100% 0; }
        }

        #controls {
            padding: 20px 40px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            transition: opacity 0.3s ease-in-out;
        }

        .right-controls {
            display: flex;
            gap: 20px;
        }

        .control-btn {
            width: 100px;
            height: 100px;
            background-color: rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: rgba(255,255,255,0.7);
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            padding-top: 5px;
        }

        .control-btn img {
            width: 50%;
            height: 50%;
            object-fit: contain;
            filter: drop-shadow(0 0 5px #00aaff);
            mix-blend-mode: screen;
        }

        .control-btn:active {
            background-color: rgba(255, 255, 255, 0.2);
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(0,0,0,0.7);
        }

        #joystick-container {
            width: 150px;
            height: 150px;
            background-color: rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            position: relative;
        }

        #joystick-knob {
            width: 70px;
            height: 70px;
            background-color: rgba(255,255,255,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 50%;
            position: absolute;
            cursor: grab;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease-out;
        }

        #joystick-knob:active {
            cursor: grabbing;
            background-color: rgba(255,255,255,0.5);
        }

        #intro-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 1;
            transition: opacity 1s ease-out;
        }

        #intro-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: cover;
            width: 100%;
            height: 100%;
        }

        #menu-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 99;
            color: white;
            opacity: 0;
            transition: opacity 0.5s ease-in;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .menu-option {
            margin: 15px 0;
            font-size: 1.5em;
            background-color: rgba(0,0,0,0.7);
            border: 1px solid rgba(0, 170, 255, 0.5);
            border-radius: 10px;
            padding: 15px 30px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            color: white;
            text-align: center;
            width: 250px;
        }

        .menu-option:hover {
            background-color: rgba(0, 170, 255, 0.3);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 170, 255, 0.3);
        }

        .menu-option:active {
            transform: scale(0.98);
            box-shadow: 0 2px 8px rgba(0,0,0,0.7);
        }

        #language-select-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 15px 30px;
        }

        #language-select {
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid #00aaff;
            background-color: rgba(0,0,0,0.8);
            color: white;
            font-size: 1em; /* Adjusted font size */
            cursor: pointer;
            outline: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23ffffff%22%20d%3D%22M287%2069.4L154.1%20202.3c-4.4%204.4-10.9%204.4-15.3%200L5.4%2069.4c-4.4-4.4-4.4-10.9%200-15.3l12.4-12.4c4.4-4.4%2010.9-4.4%2015.3%200L145.7%20174%20259.3%2041.7c4.4-4.4%2010.9-4.4%2015.3%200l12.4%2012.4c4.5%204.5%204.5%2010.9.1%2015.3z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 12px;
        }

        #language-select:focus {
            border-color: #3498db;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
        }
        
        #door-prompt-flame {
            position: absolute;
            width: 30px;
            height: 45px;
            background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(200,225,255,0.8) 40%, rgba(150,200,255,0) 70%);
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            box-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #00aaff;
            transform: translate(-50%, -50%) rotate(-45deg);
            display: none;
            z-index: 10;
            pointer-events: auto;
            cursor: pointer;
            animation: pulse 1.5s infinite ease-in-out;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) rotate(-45deg) scale(1); opacity: 0.8; }
            50% { transform: translate(-50%, -50%) rotate(-45deg) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) rotate(-45deg) scale(1); opacity: 0.8; }
        }


        #start-button-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 101;
        }

        #start-button {
            padding: 20px 40px;
            font-size: 2em;
            background-color: #3498db;
            border: none;
            border-radius: 15px;
            color: white;
            cursor: pointer;
            box-shadow: 0 5px 20px rgba(0, 170, 255, 0.5);
            transition: background-color 0.3s, transform 0.1s;
        }

        #start-button:hover {
            background-color: #2980b9;
        }

        #start-button:active {
            transform: scale(0.95);
        }

        #pause-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 102;
            color: white;
            opacity: 0;
            transition: opacity 0.3s ease-in;
            text-align: center;
        }

        #pause-menu.active {
            display: flex;
            opacity: 1;
        }

        .menu-item {
            margin: 10px;
            font-size: 1.5em;
        }
        
        .pause-button {
            margin: 10px 0;
            font-size: 1.2em;
            background-color: rgba(52, 152, 219, 0.8);
            border: 1px solid rgba(0, 170, 255, 0.5);
            border-radius: 10px;
            padding: 12px 25px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            color: white;
            width: 250px;
        }
        .pause-button:hover {
            background-color: rgba(41, 128, 185, 1);
        }


        .slider-container {
            width: 250px;
            margin: 10px auto;
        }

        .slider {
            width: 100%;
            cursor: pointer;
        }

        .close-btn {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #3498db;
            border: none;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            font-size: 1.2em;
        }
        
        .audio-control-panel {
            border-top: 1px solid #3498db;
            margin-top: 20px;
            padding-top: 10px;
        }

        .audio-control {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 350px;
            margin: 5px 0;
        }
        
        .audio-control button {
            padding: 5px 10px;
            background-color: #3498db;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 5px;
        }

        #transition-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #000;
            z-index: 200;
            pointer-events: none;
            opacity: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.4s ease-in-out;
        }

        #transition-overlay.visible {
            opacity: 1;
        }

        #loading-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        #loading-image {
            width: 80vw;
            max-width: 800px;
            height: auto;
            object-fit: contain;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 170, 255, 0.5);
        }

        #loading-text {
            font-size: 2.5em;
            color: white;
            text-shadow: 2px 2px 5px black;
        }
        
        #numerals-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .door-numeral {
            position: absolute;
            transform: translate(-50%, -100%);
            font-family: 'Cinzel', serif;
            color: #fff;
            font-size: 2em;
            font-weight: 700;
            pointer-events: none;
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #fff, 0 0 20px #00aaff, 0 0 30px #00aaff;
            display: block;
            transition: color 0.5s, text-shadow 0.5s;
        }

        .door-numeral.off {
            color: #555;
            text-shadow: 1px 1px 2px #000;
        }
        
        #dialogue-box {
            position: fixed;
            bottom: 25%;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 700px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #00aaff;
            border-radius: 15px;
            padding: 20px;
            color: white;
            font-size: 1.5em;
            font-family: 'Cinzel', serif;
            text-align: center;
            z-index: 50;
            display: none;
            pointer-events: none;
            box-shadow: 0 0 15px rgba(0, 170, 255, 0.5);
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        #dialogue-box.visible {
            display: block;
            opacity: 1;
        }

        #gamepad-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 100;
            display: none;
        }

    </style>
</head>
<body>
    <div id="start-button-container">
        <button id="start-button" data-translate-key="start">Empezar</button>
    </div>

    <div id="intro-screen">
        <img id="intro-image" src="" alt="Intro Image">
    </div>

    <div id="menu-screen" class="menu-option">
        <div id="language-select-container">
            <label for="language-select" data-translate-key="languageLabel">IDIOMA:</label>
            <select id="language-select">
                <option value="es">Español</option>
                <option value="en">English</option>
            </select>
        </div>
        <button id="play-button" class="menu-option" data-translate-key="play">JUGAR</button>
    </div>

    <canvas id="bg-canvas"></canvas>
    <div id="ui-container">
        <div id="numerals-container"></div>
        <div id="ui-top">
            <div class="player-info">
                <div id="player-profile-container">
                    <img id="player-profile-image" src="https://raw.githubusercontent.com/Yanzsmartwood2025/JUSN38/701301ad76b7ae323e026cd8577529b52229e75f/assets/images/barra-de-energia.png" alt="Energy Bar Profile">
                    <div id="joziel-halo"></div>
                </div>
                <div class="stats-group">
                    <div id="energy-bar">
                        <div id="energy-fill"></div>
                    </div>
                    <div id="power-bar">
                        <div id="power-fill" class="stat-bar-fill"></div>
                    </div>
                </div>
                <div class="stat-label">JOZIEL</div>
            </div>
            <div id="gamepad-status" data-translate-key="gamepadConnected">Control Conectado</div>
        </div>
        <div id="controls">
            <div id="joystick-container">
                <div id="joystick-knob"></div>
            </div>
            <div class="right-controls">
                <div id="btn-shoot" class="control-btn">
                     <img src="https://raw.githubusercontent.com/Yanzsmartwood2025/JUSN38/3baccf9aa782b7455c20496cdd2e7fbafa7c8286/assets/images/fuego.png" alt="Shoot">
                     <span data-translate-key="shoot">Disparar</span>
                </div>
                <div id="btn-attack" class="control-btn">
                    <img src="https://raw.githubusercontent.com/Yanzsmartwood2025/JUSN38/7d3c163a9830970f045b805d108c7dec2d5e8674/assets/images/hoja_de_sprites%20(2).png" alt="Attack">
                    <span data-translate-key="attack">Atacar</span>
                </div>
            </div>
        </div>
        <div id="door-prompt-flame"></div>
        <div id="dialogue-box"></div>
    </div>

    <div id="pause-menu">
        <h2 data-translate-key="settings">Configuración</h2>
        <div class="menu-item">
            <p data-translate-key="languageLabel">Idioma:</p>
            <select id="pause-language-select">
                <option value="es">Español</option>
                <option value="en">English</option>
            </select>
        </div>
        
        <button id="gamepad-toggle" class="pause-button" data-translate-key="activateGamepad">Activar Control</button>
        
        <button id="vibration-toggle" class="pause-button" data-translate-key="toggleVibrationOn">Vibración: ON</button>

        <div class="audio-control-panel">
            <h3 data-translate-key="audioControls">Controles de Audio</h3>
            <div class="audio-control">
                <span data-translate-key="musicVolume">Música Ambiental:</span>
                <button id="music-toggle">▶</button>
                <input type="range" id="music-volume" class="slider" min="0" max="1" step="0.1" value="0.5">
            </div>
            <div class="audio-control">
                <span data-translate-key="sfxVolume">Pasos:</span>
                <button id="sfx-toggle">▶</button>
                <input type="range" id="sfx-volume" class="slider" min="0" max="1" step="0.1" value="0.5">
            </div>
        </div>
        <button id="resume-button" class="close-btn" data-translate-key="resume">Reanudar</button>
    </div>

    <div id="transition-overlay">
        <div id="loading-content">
            <img id="loading-image" src="https://raw.githubusercontent.com/Yanzsmartwood2025/JUSN38/3bcb76b3104ebb775ad3ca7272f3d15f436d9ce3/assets/images/menu-principal.jpg" alt="Loading Screen">
            <span id="loading-text"></span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- src/game.js (Lógica Principal) ---
        
        const assetUrls = {
            runningSprite: 'https://raw.githubusercontent.com/Yanzsmartwood2025/JUSN38/91cf7a68151871314da5b27acc5dd1ff015e4290/assets/images/LumenFall.png',
            attackSprite: 'https://raw.githubusercontent.com/Yanzsmartwood2025/JUSN38/7d3c163a9830970f045b805d108c7dec2d5e8674/assets/images/hoja_de_sprites%20(2).png',
            jumpSprite: 'https://raw.githubusercontent.com/Yanzsmartwood2025/JUSN38/388c6e26b1c70e9a38f36c57f7943285e6834b17/assets/images/saltando.png',
            flameParticle: 'https://raw.githubusercontent.com/Yanzsmartwood2025/JUSN38/3baccf9aa782b7455c20496cdd2e7fbafa7c8286/assets/images/fuego.png',
            wallTexture: 'https://raw.githubusercontent.com/Yanzsmartwood2025/JUSN38/d42892ab05658bf6dd3817ab92eb7ef1f73e0d85/assets/images/pared-calabozo.png',
            doorTexture: 'https://raw.githubusercontent.com/Yanzsmartwood2025/JUSN38/d42892ab05658bf6dd3817ab92eb7ef1f73e0d85/assets/images/puerta-calabozo.png',
            floorTexture: 'https://raw.githubusercontent.com/Yanzsmartwood2025/JUSN38/d42892ab05658bf6dd3817ab92eb7ef1f73e0d85/assets/images/piso-calabozo.png',
            torchTexture: 'https://raw.githubusercontent.com/Yanzsmartwood2025/JUSN38/d42892ab05658bf6dd3817ab92eb7ef1f73e0d85/assets/images/antorcha.png',
            specterTexture: 'https://raw.githubusercontent.com/Yanzsmartwood2025/JUSN38/f84aac629032d6a02b8c34ac91d4844292e9e1ba/assets/images/fantasma.png',
            introImage: 'https://raw.githubusercontent.com/Yanzsmartwood2025/JUSN38/4b2fc282d18b5dc4b93cb8e04a179854259d421c/assets/images/Intro.jpg',
            menuBackgroundImage: 'https://raw.githubusercontent.com/Yanzsmartwood2025/JUSN38/3bcb76b3104ebb775ad3ca7272f3d15f436d9ce3/assets/images/menu-principal.jpg',
            animatedEnergyBar: 'https://raw.githubusercontent.com/Yanzsmartwood2025/JUSN38/701301ad76b7ae323e026cd8577529b52229e75f/assets/images/barra-de-energia.png',
            halleyStatueTexture: 'https://raw.githubusercontent.com/Yanzsmartwood2025/JUSN38/30e14b52cdeb5985c23a7f7fe1a1f5958a1485eb/assets/images/Halley-piedra.png'
        };

        const totalRunningFrames = 8;
        const totalAttackFrames = 6;
        const totalJumpFrames = 4;
        const totalSpecterFrames = 5;
        const animationSpeed = 80;
        const specterAnimationSpeed = 120;
        const moveSpeed = 0.2;
        const playableAreaWidth = 120;
        const roomDepth = 15;

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffers = {};
        const audioSources = {};
        const gainNodes = {};

        async function loadAudio(name, url) {
            return new Promise(async (resolve, reject) => {
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const arrayBuffer = await response.arrayBuffer();
                    audioBuffers[name] = await audioContext.decodeAudioData(arrayBuffer);
                    resolve();
                } catch (error) {
                    console.error(`Error loading audio "${name}":`, error);
                    reject(error);
                }
            });
        }
        
        function playAudio(name, loop = false) {
            if (!audioBuffers[name]) return;
            if (audioSources[name] && audioSources[name].buffer) stopAudio(name);
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffers[name];
            source.loop = loop;
            const gainNode = audioContext.createGain();
            gainNode.gain.value = 0.5;
            source.connect(gainNode).connect(audioContext.destination);
            source.start(0);
            audioSources[name] = source;
            gainNodes[name] = gainNode;
        }

        function stopAudio(name) {
            if (audioSources[name]) {
                audioSources[name].stop();
                delete audioSources[name];
            }
        }

        function setAudioVolume(name, volume) {
            if (gainNodes[name]) gainNodes[name].gain.value = volume;
        }

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('bg-canvas'), antialias: true, alpha: true });
        const textureLoader = new THREE.TextureLoader();
        const clock = new THREE.Clock();

        let player;
        const allFlames = [];
        const allSpecters = [];
        const allGates = [];
        const allStatues = []; 
        const allOrbs = [];
        const allPuzzles = [];
        const allProjectiles = [];

        let currentLevelId = 'dungeon_1';
        let isPaused = false;
        let isTransitioning = false;
        let animationFrameId;
        
        const completedRooms = { room_1: false, room_2: false, room_3: false, room_4: false, room_5: false };

        let isGamepadModeActive = false;
        let isVibrationEnabled = true;
        let isAttackButtonPressed = false;
        let attackPressStartTime = 0;
        let interactPressed = false;
        let joyVector = new THREE.Vector2(0, 0);
        let prevGamepadButtons = {};

        camera.position.set(0, 4, 8);
        camera.lookAt(0, 2, 0);
        camera.far = roomDepth + 50;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.setClearColor(0x000000, 0);

        const ambientLight = new THREE.AmbientLight(0x808080, 1.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xaaaaaa, 0.5);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        function animate() {
            if (isPaused) return;
            animationFrameId = requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            
            if (isGamepadModeActive) {
                handleGamepadInput();
            }

            if (player && !isTransitioning) {
                const attackHeld = isAttackButtonPressed && (Date.now() - attackPressStartTime > 200);
                player.update(deltaTime, { joyVector, attackHeld });

                let isNearInteractable = false;
                let interactableObject = null;
                
                allGates.forEach(gate => {
                    const distanceX = Math.abs(player.mesh.position.x - gate.mesh.position.x);
                    if (distanceX < 4) {
                        isNearInteractable = true;
                        interactableObject = {type: 'gate', object: gate};
                    }
                    const screenPosition = gate.mesh.position.clone();
                    screenPosition.y += 6.8;
                    const vector = screenPosition.project(camera);
                    const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
                    const y = (-vector.y * 0.5 + 0.5) * renderer.domElement.clientHeight;
                    gate.numeralElement.style.left = `${x}px`;
                    gate.numeralElement.style.top = `${y}px`;
                });
                
                allPuzzles.forEach(puzzle => {
                    if (!puzzle.isSolved) {
                        const distanceX = Math.abs(player.mesh.position.x - puzzle.mesh.position.x);
                        if (distanceX < 5) {
                            isNearInteractable = true;
                            interactableObject = {type: 'puzzle', object: puzzle};
                        }
                    }
                });

                allStatues.forEach(statue => {
                    const distanceX = Math.abs(player.mesh.position.x - statue.mesh.position.x);
                    if (distanceX < 5) {
                        isNearInteractable = true;
                        interactableObject = {type: 'statue', object: statue};
                    }
                });

                if (isNearInteractable) {
                    const screenPosition = interactableObject.object.mesh.position.clone();
                    screenPosition.y += (interactableObject.type === 'gate' ? 5 : 4);
                    const vector = screenPosition.project(camera);
                    const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
                    const y = (-vector.y * 0.5 + 0.5) * renderer.domElement.clientHeight;
                    doorPromptFlame.style.left = `${x}px`;
                    doorPromptFlame.style.top = `${y}px`;
                    doorPromptFlame.style.display = 'block';

                    if (interactPressed) {
                        if (interactableObject.type === 'gate') {
                            const gate = interactableObject.object;
                            const destinationId = gate.destination;
                            let spawnX = null;
                            if (destinationId === 'dungeon_1') {
                                const roomNumber = gate.id.split('_')[1];
                                const targetGateId = `gate_${roomNumber}`;
                                const targetGate = MAPS.dungeon_1.gates.find(g => g.id === targetGateId);
                                if (targetGate) {
                                    spawnX = targetGate.x;
                                }
                            }
                            triggerTransition(destinationId, spawnX);
                        } else if (interactableObject.type === 'puzzle') {
                            interactableObject.object.solve();
                        } else if (interactableObject.type === 'statue') { 
                            interactableObject.object.interact();
                        }
                    }
                } else {
                    doorPromptFlame.style.display = 'none';
                }

                const isMoving = Math.abs(joyVector.x) > 0.1;
                if (isMoving && player.isGrounded) {
                    if (!audioSources['pasos']) playAudio('pasos', true);
                } else {
                    if (audioSources['pasos']) stopAudio('pasos');
                }
            }
            
            interactPressed = false;
            allFlames.forEach(flame => flame.update(deltaTime));
            allSpecters.forEach(specter => specter.update(deltaTime, player));
            allPuzzles.forEach(puzzle => puzzle.update(deltaTime));
            
            for (let i = allProjectiles.length - 1; i >= 0; i--) {
                if (!allProjectiles[i].update(deltaTime)) {
                    scene.remove(allProjectiles[i].mesh);
                    allProjectiles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        const startButtonContainer = document.getElementById('start-button-container');
        const startButton = document.getElementById('start-button');
        const introScreen = document.getElementById('intro-screen');
        const introImage = document.getElementById('intro-image');
        const menuScreen = document.getElementById('menu-screen');
        const playButton = document.getElementById('play-button');
        const languageSelect = document.getElementById('language-select');
        const pauseLanguageSelect = document.getElementById('pause-language-select');
        const btnAttack = document.getElementById('btn-attack');
        const btnShoot = document.getElementById('btn-shoot');
        const doorPromptFlame = document.getElementById('door-prompt-flame');
        const jozielHalo = document.getElementById('joziel-halo');
        const pauseMenu = document.getElementById('pause-menu');
        const resumeButton = document.getElementById('resume-button');
        const musicVolumeSlider = document.getElementById('music-volume');
        const sfxVolumeSlider = document.getElementById('sfx-volume');
        const musicToggleButton = document.getElementById('music-toggle');
        const sfxToggleButton = document.getElementById('sfx-toggle');
        const transitionOverlay = document.getElementById('transition-overlay');
        const loadingContent = document.getElementById('loading-content');
        const loadingText = document.getElementById('loading-text');
        const numeralsContainer = document.getElementById('numerals-container');
        const dialogueBox = document.getElementById('dialogue-box');
        const gamepadStatus = document.getElementById('gamepad-status');
        const gamepadToggleButton = document.getElementById('gamepad-toggle');
        const vibrationToggleButton = document.getElementById('vibration-toggle');
        const controlsContainer = document.getElementById('controls');
        
        let currentLanguage = 'es';
        const translations = {
            es: {
                start: "Empezar",
                loading: "Cargando...",
                play: "JUGAR",
                languageLabel: "IDIOMA:",
                settings: "Configuración",
                musicVolume: "Música Ambiental:",
                sfxVolume: "Pasos:",
                resume: "Reanudar",
                gamepadConnected: "Control Conectado",
                audioControls: "Controles de Audio",
                halleyStatueDialogue: "Esta es la estatua de Halley, la primera guardiana. Su luz guió a los perdidos.",
                shoot: "Disparar",
                attack: "Atacar",
                activateGamepad: "Activar Control",
                deactivateGamepad: "Activar Táctil",
                toggleVibrationOn: "Vibración: ON",
                toggleVibrationOff: "Vibración: OFF"
            },
            en: {
                start: "Start",
                loading: "Loading...",
                play: "PLAY",
                languageLabel: "LANGUAGE:",
                settings: "Settings",
                musicVolume: "Ambient Music:",
                sfxVolume: "Footsteps:",
                resume: "Resume",
                gamepadConnected: "Gamepad Connected",
                audioControls: "Audio Controls",
                halleyStatueDialogue: "This is the statue of Halley, the first guardian. Her light guided the lost.",
                shoot: "Shoot",
                attack: "Attack",
                activateGamepad: "Activate Gamepad",
                deactivateGamepad: "Activate Touch",
                toggleVibrationOn: "Vibration: ON",
                toggleVibrationOff: "Vibration: OFF"
            }
        };

        function updateUIText() {
            const lang = translations[currentLanguage];
            document.querySelectorAll('[data-translate-key]').forEach(el => {
                const key = el.dataset.translateKey;
                if (lang[key]) {
                    el.textContent = lang[key];
                }
            });
            
            gamepadToggleButton.textContent = isGamepadModeActive 
                ? lang.deactivateGamepad 
                : lang.activateGamepad;

            vibrationToggleButton.textContent = isVibrationEnabled
                ? lang.toggleVibrationOn
                : lang.toggleVibrationOff;
            
            // Update dynamic text if visible
            if (transitionOverlay.classList.contains('visible')) {
                loadingText.textContent = lang.loading;
            }
        }

        function showDialogue(dialogueKey, duration) {
            if (dialogueBox.classList.contains('visible')) return;
            const message = translations[currentLanguage][dialogueKey] || "Dialogue not found.";
            dialogueBox.textContent = message;
            dialogueBox.classList.add('visible');
            setTimeout(() => {
                dialogueBox.classList.remove('visible');
            }, duration);
        }

        function triggerTransition(destinationId, spawnX = null) {
            if (isTransitioning) return;
            isTransitioning = true;

            loadingText.textContent = translations[currentLanguage].loading;
            transitionOverlay.classList.add('visible');

            setTimeout(() => {
                loadLevelById(destinationId, spawnX);
                
                setTimeout(() => {
                    transitionOverlay.classList.remove('visible');
                    isTransitioning = false;
                }, 1000); // Reduced transition time
            }, 400);
        }

        async function startGame() {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            try {
                await Promise.all([
                    loadAudio('pasos', 'assets/mp3/LUMENFALL/Pasos-Joziel.mp3'),
                    loadAudio('ambiente', 'assets/mp3/LUMENFALL/calabozo_de_piedra.mp3')
                ]);
            } catch (error) {
                console.error("Error loading audio", error);
            }
            playAudio('ambiente', true);
            setAudioVolume('ambiente', musicVolumeSlider.value);
            setAudioVolume('pasos', sfxVolumeSlider.value);

            menuScreen.style.opacity = 0;
            menuScreen.addEventListener('transitionend', () => {
                menuScreen.style.display = 'none';
                document.getElementById('bg-canvas').style.display = 'block';
                document.getElementById('ui-container').style.display = 'flex';
                player = new Player();
                loadLevelById(currentLevelId);
                animate();
            }, { once: true });
        }

        function pauseGame() {
            if (isPaused) return;
            isPaused = true;
            stopAudio('ambiente');
            stopAudio('pasos');
            cancelAnimationFrame(animationFrameId);
            pauseMenu.classList.add('active');
        }

        function resumeGame() {
            if (!isPaused) return;
            isPaused = false;
            playAudio('ambiente', true);
            pauseMenu.classList.remove('active');
            animate();
        }
        
        function handleLanguageChange(e) {
            currentLanguage = e.target.value;
            languageSelect.value = currentLanguage;
            pauseLanguageSelect.value = currentLanguage;
            updateUIText();
        }

        function toggleGamepadMode() {
            isGamepadModeActive = !isGamepadModeActive;
            controlsContainer.style.opacity = isGamepadModeActive ? '0' : '1';
            controlsContainer.style.pointerEvents = isGamepadModeActive ? 'none' : 'auto';
            updateUIText();
        }

        function toggleVibration() {
            isVibrationEnabled = !isVibrationEnabled;
            updateUIText();
        }

        languageSelect.addEventListener('change', handleLanguageChange);
        pauseLanguageSelect.addEventListener('change', handleLanguageChange);

        playButton.addEventListener('click', startGame);
        jozielHalo.addEventListener('click', pauseGame);
        resumeButton.addEventListener('click', resumeGame);
        gamepadToggleButton.addEventListener('click', toggleGamepadMode);
        vibrationToggleButton.addEventListener('click', toggleVibration);
        musicVolumeSlider.addEventListener('input', (e) => setAudioVolume('ambiente', e.target.value));
        sfxVolumeSlider.addEventListener('input', (e) => setAudioVolume('pasos', e.target.value));
        
        musicToggleButton.addEventListener('click', () => {
            if (audioSources['ambiente']) {
                stopAudio('ambiente');
                musicToggleButton.textContent = '▶';
            } else {
                playAudio('ambiente', true);
                musicToggleButton.textContent = '❚❚';
            }
        });
        sfxToggleButton.addEventListener('click', () => {
            if (audioSources['pasos']) {
                stopAudio('pasos');
                sfxToggleButton.textContent = '▶';
            } else {
                playAudio('pasos', true);
                sfxToggleButton.textContent = '❚❚';
            }
        });


        const joystickContainer = document.getElementById('joystick-container');
        const joystickKnob = document.getElementById('joystick-knob');
        let isDraggingJoystick = false;
        let joystickTouchId = null; // <-- NEW: To store the ID of the touch on the joystick
        let joystickRect;
        let joystickRadius;

        function updateJoystickDimensions() {
            if (joystickContainer) {
                joystickRect = joystickContainer.getBoundingClientRect();
                joystickRadius = joystickContainer.clientWidth / 2 - joystickKnob.clientWidth / 2;
            }
        }

        function moveJoystick(clientX, clientY) {
            let deltaX = clientX - (joystickRect.left + joystickRect.width / 2);
            let deltaY = clientY - (joystickRect.top + joystickRect.height / 2);
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            if (distance > joystickRadius) {
                const angle = Math.atan2(deltaY, deltaX);
                deltaX = joystickRadius * Math.cos(angle);
                deltaY = joystickRadius * Math.sin(angle);
            }
            joystickKnob.style.transform = `translate(-50%, -50%) translate(${deltaX}px, ${deltaY}px)`;
            const deadZone = 10;
            joyVector.x = Math.abs(deltaX) > deadZone ? deltaX / joystickRadius : 0;
            joyVector.y = Math.abs(deltaY) > deadZone ? -deltaY / joystickRadius : 0;
        }

        function resetJoystick() {
            joystickKnob.style.transition = 'transform 0.1s ease-out';
            joystickKnob.style.transform = 'translate(-50%, -50%)';
            joyVector.set(0, 0);
        }
        
        // --- MOBILE-FRIENDLY JOYSTICK CONTROLS ---

        // Mouse Events (for desktop)
        joystickContainer.addEventListener('mousedown', (e) => { 
            if (!isPaused && !isGamepadModeActive) { 
                isDraggingJoystick = true; 
                joystickKnob.style.transition = 'none'; 
                updateJoystickDimensions(); 
                moveJoystick(e.clientX, e.clientY);
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDraggingJoystick && joystickTouchId === null && !isGamepadModeActive) { // Only move if controlled by mouse
                moveJoystick(e.clientX, e.clientY);
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDraggingJoystick && joystickTouchId === null && !isGamepadModeActive) { // Only reset if controlled by mouse
                isDraggingJoystick = false;
                resetJoystick();
            } 
        });

        // Touch Events (for mobile)
        joystickContainer.addEventListener('touchstart', (e) => { 
            if (!isPaused && !isGamepadModeActive && joystickTouchId === null) { // Only start a new drag if not already dragging
                e.preventDefault();
                const touch = e.changedTouches[0]; // Get the touch that started
                joystickTouchId = touch.identifier; // Store its ID
                isDraggingJoystick = true; 
                joystickKnob.style.transition = 'none'; 
                updateJoystickDimensions(); 
                moveJoystick(touch.clientX, touch.clientY);
            } 
        }, { passive: false });

        document.addEventListener('touchmove', (e) => { 
            if (isDraggingJoystick && joystickTouchId !== null && !isGamepadModeActive) {
                e.preventDefault();
                // Find the touch that corresponds to our joystick drag
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    if (touch.identifier === joystickTouchId) {
                        moveJoystick(touch.clientX, touch.clientY);
                        break;
                    }
                }
            } 
        }, { passive: false });
        
        document.addEventListener('touchend', (e) => {
            if (isDraggingJoystick && joystickTouchId !== null && !isGamepadModeActive) {
                // Check if the touch that ended is the one we were tracking
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    if (touch.identifier === joystickTouchId) {
                        isDraggingJoystick = false;
                        joystickTouchId = null; // Release the touch ID
                        resetJoystick();
                        break;
                    }
                }
            } 
        });

        document.addEventListener('touchcancel', (e) => { // Also handle touchcancel
             if (isDraggingJoystick && joystickTouchId !== null && !isGamepadModeActive) {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    if (touch.identifier === joystickTouchId) {
                        isDraggingJoystick = false;
                        joystickTouchId = null;
                        resetJoystick();
                        break;
                    }
                }
            }
        });
        
        function handleAttackPressStart() {
            if (isPaused) return;
            isAttackButtonPressed = true;
            attackPressStartTime = Date.now();
        }
        function handleAttackPressEnd() {
            if (isPaused) return;
            isAttackButtonPressed = false;
        }

        btnAttack.addEventListener('mousedown', () => !isGamepadModeActive && handleAttackPressStart());
        btnAttack.addEventListener('mouseup', () => !isGamepadModeActive && handleAttackPressEnd());
        btnAttack.addEventListener('touchstart', (e) => { if(!isGamepadModeActive) { e.preventDefault(); handleAttackPressStart(); } }, { passive: false });
        btnAttack.addEventListener('touchend', () => !isGamepadModeActive && handleAttackPressEnd());

        btnShoot.addEventListener('mousedown', () => { if(!isPaused && !isGamepadModeActive) player.shoot(joyVector); });
        btnShoot.addEventListener('touchstart', (e) => { if(!isPaused && !isGamepadModeActive) { e.preventDefault(); player.shoot(joyVector); } }, { passive: false });


        doorPromptFlame.addEventListener('mousedown', (e) => { if (!isPaused) { e.preventDefault(); interactPressed = true; } });
        doorPromptFlame.addEventListener('touchstart', (e) => { if (!isPaused) { e.preventDefault(); interactPressed = true; } }, { passive: false });
        
        startButton.addEventListener('click', () => {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            startButtonContainer.style.display = 'none';
            introImage.src = assetUrls.introImage;
            introScreen.style.opacity = 0;
            introScreen.addEventListener('transitionend', () => {
                introScreen.style.display = 'none';
                menuScreen.style.backgroundImage = `url('${assetUrls.menuBackgroundImage}')`;
                menuScreen.style.display = 'flex';
                setTimeout(() => menuScreen.style.opacity = 1, 10);
            }, { once: true });
        });
        
        function handleResize() {
            updateJoystickDimensions();
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            
            if (camera.aspect < 1) {
                camera.zoom = 1.2;
            } else {
                camera.zoom = 1.0;
            }
            
            camera.updateProjectionMatrix();
        }

        window.addEventListener('load', () => {
            updateUIText();
            handleResize();
        });
        window.addEventListener('resize', handleResize);

        window.addEventListener("gamepadconnected", (e) => {
            gamepadStatus.style.display = 'block';
            updateUIText();
        });
        window.addEventListener("gamepaddisconnected", (e) => {
            gamepadStatus.style.display = 'none';
        });

        function vibrateGamepad(duration = 50, strong = 0.8, weak = 0.8) {
            if (!isVibrationEnabled) return;
            const gp = navigator.getGamepads()[0];
            if (gp && gp.vibrationActuator) {
                gp.vibrationActuator.playEffect("dual-rumble", {
                    startDelay: 0,
                    duration: duration,
                    weakMagnitude: weak,
                    strongMagnitude: strong,
                });
            }
        }

        function handleGamepadInput() {
            const gamepads = navigator.getGamepads();
            if (!gamepads[0]) return;
            const gp = gamepads[0];

            const deadzone = 0.2;
            const axisX = gp.axes[0];
            const axisY = gp.axes[1];
            joyVector.x = Math.abs(axisX) > deadzone ? axisX : 0;
            joyVector.y = Math.abs(axisY) > deadzone ? -axisY : 0;

            const shootNow = gp.buttons[0].pressed;
            if (shootNow && !prevGamepadButtons[0]) {
                player.shoot(joyVector);
            }
            prevGamepadButtons[0] = shootNow;
            
            const attackNow = gp.buttons[2].pressed;
            if (attackNow && !prevGamepadButtons[2]) {
                handleAttackPressStart();
            } else if (!attackNow && prevGamepadButtons[2]) {
                handleAttackPressEnd();
            }
            prevGamepadButtons[2] = attackNow;
            
            const interactNow = gp.buttons[3].pressed;
            if (interactNow && !prevGamepadButtons[3]) {
                interactPressed = true;
            }
            prevGamepadButtons[3] = interactNow;

            const pauseNow = gp.buttons[9].pressed;
            if (pauseNow && !prevGamepadButtons[9]) {
                isPaused ? resumeGame() : pauseGame();
            }
            prevGamepadButtons[9] = pauseNow;
        }

        class Player {
             constructor() {
                this.runningTexture = textureLoader.load(assetUrls.runningSprite);
                this.attackTexture = textureLoader.load(assetUrls.attackSprite);
                this.jumpTexture = textureLoader.load(assetUrls.jumpSprite);

                this.runningTexture.repeat.x = 1 / totalRunningFrames;
                this.attackTexture.repeat.x = 1 / totalAttackFrames;
                this.jumpTexture.repeat.x = 1 / totalJumpFrames;
                
                const playerHeight = 2.8;
                const playerWidth = 2.8;

                const playerGeometry = new THREE.PlaneGeometry(playerWidth, playerHeight);
                const playerMaterial = new THREE.MeshStandardMaterial({ map: this.runningTexture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
                this.mesh = new THREE.Mesh(playerGeometry, playerMaterial);
                this.mesh.position.y = playerHeight / 2;
                this.mesh.castShadow = true;
                scene.add(this.mesh);

                this.playerLight = new THREE.PointLight(0xffffff, 0.5, 8);
                scene.add(this.playerLight);
                
                this.createAttackFlame();

                this.currentState = 'idle';
                this.currentFrame = 0;
                this.lastFrameTime = 0;
                this.isFacingLeft = false;
                this.isGrounded = true;
                this.velocity = new THREE.Vector3();
                this.jumpPower = 0.35;
                this.gravity = -0.025;
                this.isJumping = false;
                this.minPlayerX = -playableAreaWidth/2 + 1.5;
                this.maxPlayerX = playableAreaWidth/2 - 1.5;
                this.jumpInputReceived = false;
                this.shootCooldown = 0;
                this.shootCooldownDuration = 0.5;
                this.shootingTimer = 0;
            }

            shoot(aimVector) {
                if (this.shootCooldown > 0) return;
                vibrateGamepad(50, 0.5, 0.5);
                
                const startPosition = this.mesh.position.clone().add(new THREE.Vector3(0, 0.2, 0.5));
                let direction = new THREE.Vector2(this.isFacingLeft ? -1 : 1, 0);
                
                if (Math.abs(aimVector.y) > 0.3) {
                    direction.y = aimVector.y;
                }
                direction.normalize();

                allProjectiles.push(new Projectile(scene, startPosition, direction));
                this.shootCooldown = this.shootCooldownDuration;
                this.currentState = 'shooting';
                this.shootingTimer = 0.2;
            }

            createAttackFlame() {
                const flameGroup = new THREE.Group();
                const flameLight = new THREE.PointLight(0x00aaff, 1.5, 4);
                flameLight.castShadow = true;
                flameGroup.add(flameLight);
                const attackFlameMaterial = new THREE.MeshBasicMaterial({ map: textureLoader.load(assetUrls.flameParticle), color: 0xaaddff, transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide });
                const flameCore = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.5), attackFlameMaterial);
                flameGroup.add(flameCore);
                flameGroup.visible = false;
                this.mesh.add(flameGroup);
                this.rightHandFlame = flameGroup;
                this.rightHandFlame.position.set(-0.6, 0.3, 0.3);

                const leftHandFlame = flameGroup.clone();
                this.mesh.add(leftHandFlame);
                this.leftHandFlame = leftHandFlame;
                this.leftHandFlame.position.set(0.6, 0.3, 0.3);
            }
            
            updateAttackFlames() {
                [this.rightHandFlame, this.leftHandFlame].forEach(flame => {
                    const light = flame.children[0];
                    const core = flame.children[1];
                    light.intensity = 1.0 + Math.random() * 0.5;
                    const scale = 0.8 + Math.random() * 0.4;
                    core.scale.set(scale, scale, scale);
                    core.rotation.z += 0.1;
                });
            }

            update(deltaTime, controls) {
                if (this.shootCooldown > 0) {
                    this.shootCooldown -= deltaTime;
                }
                if (this.shootingTimer > 0) {
                    this.shootingTimer -= deltaTime;
                    if (this.shootingTimer <= 0) {
                        this.currentState = 'idle';
                    }
                }

                const joyX = controls.joyVector.x;
                const joyY = controls.joyVector.y;
                const isMoving = Math.abs(joyX) > 0.1;
                const previousState = this.currentState;
                
                if (this.currentState !== 'shooting') {
                    if (controls.attackHeld) {
                        if(this.currentState !== 'attacking') vibrateGamepad(100, 0.8, 0.8);
                        this.currentState = 'attacking';
                    } else {
                        const isJumpingInput = joyY > 0.5;
                        if (isJumpingInput && this.isGrounded && !this.jumpInputReceived) {
                            this.isJumping = true;
                            this.isGrounded = false;
                            this.velocity.y = this.jumpPower;
                            this.currentState = 'jumping';
                            this.jumpInputReceived = true;
                        } else if (!isJumpingInput) {
                            this.jumpInputReceived = false;
                        }

                        if (isMoving) {
                            this.currentState = 'running';
                            this.mesh.position.x += moveSpeed * joyX;
                            this.isFacingLeft = joyX < 0;
                        } else if (!this.isJumping) {
                            this.currentState = 'idle';
                        }
                    }
                }
                
                if (!this.isGrounded) this.velocity.y += this.gravity;
                this.mesh.position.y += this.velocity.y;
                
                if (this.mesh.position.y <= this.mesh.geometry.parameters.height / 2) {
                    this.mesh.position.y = this.mesh.geometry.parameters.height / 2;
                    this.isGrounded = true;
                    this.isJumping = false;
                    this.velocity.y = 0;
                }

                this.mesh.position.x = Math.max(this.minPlayerX, Math.min(this.maxPlayerX, this.mesh.position.x));
                this.mesh.rotation.y = this.isFacingLeft ? Math.PI : 0;
                camera.position.x = this.mesh.position.x;
                this.playerLight.position.set(this.mesh.position.x, this.mesh.position.y + 1, this.mesh.position.z + 2);

                if (this.currentState !== previousState) this.currentFrame = 0;
                
                const isAttacking = this.currentState === 'attacking';
                this.rightHandFlame.visible = isAttacking;
                this.leftHandFlame.visible = isAttacking;
                if (isAttacking) this.updateAttackFlames();

                if (Date.now() - this.lastFrameTime > animationSpeed) {
                    this.lastFrameTime = Date.now();
                    let totalFrames, currentTexture;
                    switch (this.currentState) {
                        case 'shooting': [totalFrames, currentTexture] = [totalAttackFrames, this.attackTexture]; this.currentFrame = 2; break;
                        case 'attacking': [totalFrames, currentTexture] = [totalAttackFrames, this.attackTexture]; if (this.currentFrame < totalFrames - 1) this.currentFrame++; break;
                        case 'running': [totalFrames, currentTexture] = [totalRunningFrames, this.runningTexture]; this.currentFrame = (this.currentFrame + 1) % totalFrames; break;
                        case 'jumping': [totalFrames, currentTexture] = [totalJumpFrames, this.jumpTexture]; this.currentFrame = this.velocity.y > 0 ? 1 : 2; break;
                        default: [totalFrames, currentTexture] = [totalAttackFrames, this.attackTexture]; this.currentFrame = 0; break;
                    }
                    if (currentTexture) {
                        this.mesh.material.map = currentTexture;
                        currentTexture.offset.x = this.currentFrame / totalFrames;
                    }
                }
            }
        }

        const wallTexture = textureLoader.load(assetUrls.wallTexture);
        wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
        const wallMaterial = new THREE.MeshStandardMaterial({ map: wallTexture, color: 0x454555 });
        const doorTexture = textureLoader.load(assetUrls.doorTexture);
        const doorMaterial = new THREE.MeshStandardMaterial({ map: doorTexture, transparent: true, alphaTest: 0.5 });
        const floorTexture = textureLoader.load(assetUrls.floorTexture);
        floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(playableAreaWidth / 4, roomDepth / 5);
        const floorMaterial = new THREE.MeshStandardMaterial({ map: floorTexture });
        const torchTexture = textureLoader.load(assetUrls.torchTexture);
        const torchMaterial = new THREE.MeshStandardMaterial({ map: torchTexture, transparent: true, alphaTest: 0.5, side: THREE.DoubleSide });
        const floorGeometry = new THREE.PlaneGeometry(playableAreaWidth, roomDepth);

        function clearSceneForLevelLoad() {
            for (let i = scene.children.length - 1; i >= 0; i--) {
                const obj = scene.children[i];
                if (obj !== player.mesh && obj !== player.playerLight && !(obj instanceof THREE.Camera) && !(obj instanceof THREE.Light)) {
                    scene.remove(obj);
                }
            }
            allFlames.length = 0;
            allSpecters.length = 0;
            allGates.length = 0;
            allStatues.length = 0; 
            allOrbs.length = 0;
            allPuzzles.length = 0;
            numeralsContainer.innerHTML = '';
        }
        
        function createTorch(x, y, z, isLit) {
            const torchMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 1.8), torchMaterial);
            torchMesh.position.set(x, y, z);
            scene.add(torchMesh);
            if (isLit) {
                allFlames.push(new RealisticFlame(scene, new THREE.Vector3(x, y + 1.3, z + 0.2)));
            }
        }
        
        function areAllRoomsComplete() {
            return Object.values(completedRooms).every(status => status === true);
        }

        function loadLevel(levelData) {
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.z = camera.position.z - (roomDepth / 2);
            floor.receiveShadow = true;
            scene.add(floor);

            const wall = new THREE.Mesh(new THREE.PlaneGeometry(playableAreaWidth, 20), wallMaterial);
            wall.position.set(0, 10, camera.position.z - roomDepth);
            scene.add(wall);

            const sideWallGeometry = new THREE.PlaneGeometry(roomDepth, 20);
            const leftSideWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            leftSideWall.rotation.y = Math.PI / 2;
            leftSideWall.position.set(-playableAreaWidth / 2, 10, camera.position.z - roomDepth / 2);
            scene.add(leftSideWall);
            const rightSideWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            rightSideWall.rotation.y = -Math.PI / 2;
            rightSideWall.position.set(playableAreaWidth / 2, 10, camera.position.z - roomDepth / 2);
            scene.add(rightSideWall);

            levelData.gates.forEach(gateData => {
                if (gateData.id === 'gate_boss' && !areAllRoomsComplete()) {
                    return;
                }

                const gateGroup = new THREE.Group();
                const gateMesh = new THREE.Mesh(new THREE.PlaneGeometry(8, 8), doorMaterial.clone());
                gateMesh.position.set(0, 4, 0.3);
                gateGroup.add(gateMesh);
                gateGroup.position.x = gateData.x;
                gateGroup.position.z = camera.position.z - roomDepth;
                scene.add(gateGroup);

                const numeralElement = document.createElement('div');
                numeralElement.className = 'door-numeral';
                numeralElement.textContent = gateData.numeral;
                
                let isLit = completedRooms[gateData.destination];
                if (levelData.id !== 'dungeon_1') {
                    isLit = true;
                }
                
                if (!isLit) {
                    numeralElement.classList.add('off');
                }
                
                numeralsContainer.appendChild(numeralElement);
                
                allGates.push({ mesh: gateGroup, id: gateData.id, destination: gateData.destination, numeralElement: numeralElement });
                createTorch(gateData.x - 6, 3.2, camera.position.z - roomDepth + 0.5, isLit);
                createTorch(gateData.x + 6, 3.2, camera.position.z - roomDepth + 0.5, isLit);
            });

            levelData.specters.forEach(specterData => {
                allSpecters.push(new Specter(scene, specterData.x, specterData.y));
            });

            if (levelData.puzzles) {
                levelData.puzzles.forEach(puzzleData => {
                    allPuzzles.push(new Puzzle(scene, puzzleData.x, levelData.id));
                });
            }

            if (levelData.statues) {
                levelData.statues.forEach(statueData => {
                    allStatues.push(new Statue(
                        scene,
                        statueData.x,
                        statueData.y,
                        camera.position.z - roomDepth + 2,
                        statueData.textureUrl,
                        statueData.dialogueKey // Pass the key, not the translated string
                    ));
                });
            }
        }
        
        function loadLevelById(levelId, spawnX = null) {
            const levelData = MAPS[levelId];
            if (!levelData) return;
            currentLevelId = levelId;
            clearSceneForLevelLoad();
            loadLevel(levelData);
            if (player) {
                player.mesh.position.x = spawnX !== null ? spawnX : 0;
                player.mesh.position.y = player.mesh.geometry.parameters.height / 2;
                player.mesh.position.z = 0;
                camera.position.x = player.mesh.position.x;
            }
        }

        const MAPS = {
            dungeon_1: {
                id: 'dungeon_1',
                name: 'El Salón Principal',
                gates: [
                    { id: 'gate_1', x: -50, destination: 'room_1', numeral: 'I' },
                    { id: 'gate_2', x: -30, destination: 'room_2', numeral: 'II' },
                    { id: 'gate_3', x: -10, destination: 'room_3', numeral: 'III' },
                    { id: 'gate_4', x: 10, destination: 'room_4', numeral: 'IV' },
                    { id: 'gate_5', x: 30, destination: 'room_5', numeral: 'V' },
                    { id: 'gate_boss', x: 55, destination: 'boss_room', numeral: 'VI' },
                ],
                specters: [ { type: 'fear', x: 45, y: 3.5 } ],
            },
            room_1: { id: 'room_1', name: 'Habitación 1', gates: [{ id: 'return_1', x: 0, destination: 'dungeon_1', numeral: 'I' }], specters: [], puzzles: [{x: 15}] },
            room_2: { id: 'room_2', name: 'Habitación 2', gates: [{ id: 'return_2', x: 0, destination: 'dungeon_1', numeral: 'II' }], specters: [] },
            room_3: { id: 'room_3', name: 'Habitación 3', gates: [{ id: 'return_3', x: 0, destination: 'dungeon_1', numeral: 'III' }], specters: [] },
            room_4: { id: 'room_4', name: 'Habitación 4', gates: [{ id: 'return_4', x: 0, destination: 'dungeon_1', numeral: 'IV' }], specters: [] },
            room_5: { 
                id: 'room_5', 
                name: 'Habitación 5', 
                gates: [{ id: 'return_5', x: 0, destination: 'dungeon_1', numeral: 'V' }], 
                specters: [],
                statues: [{
                    x: 15,
                    y: 3,
                    textureUrl: assetUrls.halleyStatueTexture,
                    dialogueKey: 'halleyStatueDialogue'
                }]
            },
            boss_room: { id: 'boss_room', name: 'Sala del Jefe', gates: [{ id: 'return_boss', x: 0, destination: 'dungeon_1', numeral: 'VI' }], specters: [] },
        };

        class RealisticFlame {
            constructor(scene, position) {
                this.scene = scene;
                this.position = position;
                this.particleCount = 20;
                this.velocities = [];
                this.init();
            }

            init() {
                const particleMaterial = new THREE.PointsMaterial({ color: 0x00aaff, size: 0.4, map: textureLoader.load(assetUrls.flameParticle), blending: THREE.AdditiveBlending, transparent: true, depthWrite: false });
                const particleGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.particleCount * 3);
                for (let i = 0; i < this.particleCount; i++) {
                    positions[i * 3] = this.position.x;
                    positions[i * 3 + 1] = this.position.y;
                    positions[i * 3 + 2] = this.position.z;
                    this.velocities.push({ x: (Math.random() - 0.5) * 0.02, y: Math.random() * 0.1, z: (Math.random() - 0.5) * 0.02, lifetime: Math.random() * 2 });
                }
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.particles = new THREE.Points(particleGeometry, particleMaterial);
                this.scene.add(this.particles);
                this.light = new THREE.PointLight(0x00aaff, 2.0, 20);
                this.light.position.copy(this.position);
                this.light.castShadow = true;
                this.scene.add(this.light);
            }

            update(deltaTime) {
                const positions = this.particles.geometry.attributes.position.array;
                for (let i = 0; i < this.particleCount; i++) {
                    const vel = this.velocities[i];
                    vel.lifetime -= deltaTime;
                    if (vel.lifetime <= 0) {
                        positions[i * 3] = this.position.x;
                        positions[i * 3 + 1] = this.position.y;
                        positions[i * 3 + 2] = this.position.z;
                        vel.lifetime = Math.random() * 2;
                        vel.y = Math.random() * 0.1;
                    }
                    positions[i * 3] += vel.x;
                    positions[i * 3 + 1] += vel.y;
                    positions[i * 3 + 2] += vel.z;
                }
                this.particles.geometry.attributes.position.needsUpdate = true;
                this.light.intensity = 1.0 + Math.sin(Date.now() * 0.01 + this.position.x) * 0.5;
            }
        }

        class Specter {
            constructor(scene, initialX, initialY) {
                this.scene = scene;
                this.initialX = initialX;
                this.floatingCenterY = initialY;
                this.state = 'IDLE';
                this.stateTimer = Math.random() * 2 + 2;
                this.targetPosition = new THREE.Vector3();
                this.moveSpeed = 0.05;
                this.lastFrameTime = 0;
                this.currentFrame = 0;
                this.init();
            }

            init() {
                this.texture = textureLoader.load(assetUrls.specterTexture);
                this.texture.repeat.x = 1 / totalSpecterFrames;
                const specterMaterial = new THREE.MeshStandardMaterial({ map: this.texture, color: 0x88bbff, transparent: true, opacity: 0.8, side: THREE.DoubleSide, alphaTest: 0.1 });
                const specterGeometry = new THREE.PlaneGeometry(4.2, 4.2);
                this.mesh = new THREE.Mesh(specterGeometry, specterMaterial);
                this.mesh.position.set(this.initialX, this.floatingCenterY, camera.position.z - roomDepth + 1);
                this.scene.add(this.mesh);
            }
            
            setNewState(newState) {
                this.state = newState;
                switch(this.state) {
                    case 'IDLE':
                        this.stateTimer = Math.random() * 2 + 2;
                        break;
                    case 'MOVING':
                        const newX = Math.random() * (playableAreaWidth - 20) - (playableAreaWidth / 2 - 10);
                        this.targetPosition.set(newX, this.floatingCenterY, this.mesh.position.z);
                        this.stateTimer = 10;
                        break;
                    case 'PHASING_DOWN':
                        this.stateTimer = 1.5;
                        break;
                    case 'PHASING_UP':
                        const spawnX = Math.random() * (playableAreaWidth - 20) - (playableAreaWidth / 2 - 10);
                        this.mesh.position.set(spawnX, -5, this.mesh.position.z);
                        this.stateTimer = 1.5;
                        break;
                    case 'FLEEING':
                         this.targetPosition.x = this.mesh.position.x + (this.mesh.position.x - player.mesh.position.x > 0 ? 15 : -15);
                         this.targetPosition.x = Math.max(-playableAreaWidth/2 + 5, Math.min(playableAreaWidth/2 - 5, this.targetPosition.x));
                         this.stateTimer = 3;
                        break;
                }
            }

            update(deltaTime, player) {
                this.stateTimer -= deltaTime;

                if (Date.now() - this.lastFrameTime > specterAnimationSpeed) {
                    this.lastFrameTime = Date.now();
                    this.currentFrame = (this.currentFrame + 1) % totalSpecterFrames;
                    this.texture.offset.x = this.currentFrame / totalSpecterFrames;
                }
                
                switch(this.state) {
                    case 'IDLE':
                        this.mesh.position.y = this.floatingCenterY + Math.sin(Date.now() * 0.002) * 0.5;
                        if (this.stateTimer <= 0) {
                            this.setNewState(Math.random() > 0.3 ? 'MOVING' : 'PHASING_DOWN');
                        }
                        break;
                    
                    case 'MOVING':
                    case 'FLEEING':
                        const direction = this.targetPosition.clone().sub(this.mesh.position).normalize();
                        const speed = this.state === 'FLEEING' ? this.moveSpeed * 2 : this.moveSpeed;
                        this.mesh.position.x += direction.x * speed;

                        if (direction.x > 0.01) this.mesh.scale.x = -1;
                        if (direction.x < -0.01) this.mesh.scale.x = 1;

                        if (this.mesh.position.distanceTo(this.targetPosition) < 1 || this.stateTimer <= 0) {
                            this.setNewState('IDLE');
                        }
                        break;
                    
                    case 'PHASING_DOWN':
                        this.mesh.material.opacity = Math.max(0, 1 - (1.5 - this.stateTimer) / 1.5);
                        this.mesh.position.y -= 0.1;
                        if (this.stateTimer <= 0) {
                            this.setNewState('PHASING_UP');
                        }
                        break;

                    case 'PHASING_UP':
                        this.mesh.material.opacity = Math.min(0.8, (1.5 - this.stateTimer) / 1.5);
                        this.mesh.position.y = Math.min(this.floatingCenterY, this.mesh.position.y + 0.1);
                         if (this.stateTimer <= 0) {
                            this.mesh.material.opacity = 0.8;
                            this.mesh.position.y = this.floatingCenterY;
                            this.setNewState('IDLE');
                        }
                        break;
                }
                
                if (player && this.state !== 'PHASING_DOWN' && this.state !== 'PHASING_UP' && this.state !== 'FLEEING') {
                    if (player.mesh.position.distanceTo(this.mesh.position) < 8) {
                        this.setNewState('FLEEING');
                    }
                }
            }
        }
        
        class Puzzle {
            constructor(scene, x, roomId) {
                this.scene = scene;
                this.roomId = roomId;
                this.isSolved = completedRooms[roomId];
                this.pieces = [];
                this.init(x);
                this.mesh = this.table;
            }

            init(x) {
                const tableGeometry = new THREE.BoxGeometry(8, 2, 4);
                const tableMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                this.table = new THREE.Mesh(tableGeometry, tableMaterial);
                this.table.position.set(x, 1, camera.position.z - roomDepth + 4);
                this.scene.add(this.table);

                if (this.isSolved) {
                    this.createOrb();
                    this.orb.activate();
                    return;
                }

                const texture = textureLoader.load(assetUrls.halleyStatueTexture);
                const pieceSize = 3;
                
                const correctPositions = [
                    new THREE.Vector3(-pieceSize/2, pieceSize/2, 0),
                    new THREE.Vector3(pieceSize/2, pieceSize/2, 0),
                    new THREE.Vector3(-pieceSize/2, -pieceSize/2, 0),
                    new THREE.Vector3(pieceSize/2, -pieceSize/2, 0),
                ];

                let initialPositions = [...correctPositions].sort(() => Math.random() - 0.5);

                for (let i = 0; i < 4; i++) {
                    const material = new THREE.MeshStandardMaterial({
                        map: texture.clone(),
                        transparent: true,
                        alphaTest: 0.1
                    });
                    material.map.repeat.set(0.5, 0.5);
                    material.map.offset.set((i % 2) * 0.5, (i < 2 ? 0.5 : 0));

                    const piece = new THREE.Mesh(new THREE.PlaneGeometry(pieceSize, pieceSize), material);
                    piece.position.copy(initialPositions[i]).add(new THREE.Vector3(x, 4, this.table.position.z + 2.1));
                    piece.userData.targetPosition = correctPositions[i].clone().add(new THREE.Vector3(x, 4, this.table.position.z + 2.1));
                    this.pieces.push(piece);
                    this.scene.add(piece);
                }
            }
            
            solve() {
                if (this.isSolved) return;
                this.isSolved = true;
                
                this.pieces.forEach(piece => {
                    const startPos = piece.position.clone();
                    const endPos = piece.userData.targetPosition;
                    let t = 0;
                    const duration = 1;
                    const animatePiece = () => {
                        t += 0.05;
                        piece.position.lerpVectors(startPos, endPos, Math.min(t/duration, 1.0));
                        if (t < duration) requestAnimationFrame(animatePiece);
                    };
                    animatePiece();
                });

                setTimeout(() => {
                    this.createOrb();
                    this.orb.activate();
                }, 1200);
            }

            createOrb() {
                this.orb = new Orb(this.scene, this.mesh.position.x, this.mesh.position.y + 2.5, this.roomId);
                allOrbs.push(this.orb);
            }

            update(deltaTime) {}
        }
        
        class Orb {
            constructor(scene, x, y, roomId) {
                this.scene = scene;
                this.roomId = roomId;
                this.isActive = completedRooms[roomId];
                
                this.inactiveMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
                this.activeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 2, roughness: 0.2 });
                
                const geometry = new THREE.SphereGeometry(0.5, 32, 32);
                this.mesh = new THREE.Mesh(geometry, this.isActive ? this.activeMaterial : this.inactiveMaterial);
                this.mesh.position.set(x, y, camera.position.z - roomDepth + 3);
                scene.add(this.mesh);
                
                this.light = new THREE.PointLight(0xffffff, 1, 10);
                this.light.position.copy(this.mesh.position);
                this.light.visible = this.isActive;
                scene.add(this.light);
            }

            activate() {
                if (this.isActive) return;
                this.isActive = true;
                this.mesh.material = this.activeMaterial;
                this.light.visible = true;
                completedRooms[this.roomId] = true;
            }
        }
        
        class Projectile {
            constructor(scene, startPosition, direction) {
                this.scene = scene;
                this.lifetime = 2;
                this.speed = 0.5;

                const material = new THREE.MeshBasicMaterial({
                    map: textureLoader.load(assetUrls.flameParticle),
                    color: 0xaaddff,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                });
                const geometry = new THREE.PlaneGeometry(0.5, 0.5);
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(startPosition);
                
                this.velocity = new THREE.Vector3(direction.x, direction.y, 0).multiplyScalar(this.speed);
                
                this.scene.add(this.mesh);
            }

            update(deltaTime) {
                this.lifetime -= deltaTime;
                if (this.lifetime <= 0) {
                    return false;
                }
                this.mesh.position.x += this.velocity.x;
                this.mesh.position.y += this.velocity.y;
                return true;
            }
        }

        class Statue {
            constructor(scene, x, y, z, textureUrl, dialogueKey) {
                this.scene = scene;
                this.dialogueKey = dialogueKey; // Store the key
                this.texture = textureLoader.load(textureUrl);
                const material = new THREE.MeshStandardMaterial({
                    map: this.texture,
                    transparent: true,
                    alphaTest: 0.1,
                    side: THREE.DoubleSide
                });
                const geometry = new THREE.PlaneGeometry(6, 6);
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.set(x, y, z);
                this.scene.add(this.mesh);
            }

            interact() {
                // Look up the translation when interacting
                showDialogue(this.dialogueKey, 4000);
            }
        }
    </script>
</body>
</html>
